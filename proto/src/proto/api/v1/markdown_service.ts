// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               unknown
// source: api/v1/markdown_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "memos.api.v1";

export enum NodeType {
  NODE_UNSPECIFIED = "NODE_UNSPECIFIED",
  LINE_BREAK = "LINE_BREAK",
  PARAGRAPH = "PARAGRAPH",
  CODE_BLOCK = "CODE_BLOCK",
  HEADING = "HEADING",
  HORIZONTAL_RULE = "HORIZONTAL_RULE",
  BLOCKQUOTE = "BLOCKQUOTE",
  ORDERED_LIST = "ORDERED_LIST",
  UNORDERED_LIST = "UNORDERED_LIST",
  TASK_LIST = "TASK_LIST",
  MATH_BLOCK = "MATH_BLOCK",
  TABLE = "TABLE",
  EMBEDDED_CONTENT = "EMBEDDED_CONTENT",
  TEXT = "TEXT",
  BOLD = "BOLD",
  ITALIC = "ITALIC",
  BOLD_ITALIC = "BOLD_ITALIC",
  CODE = "CODE",
  IMAGE = "IMAGE",
  LINK = "LINK",
  AUTO_LINK = "AUTO_LINK",
  TAG = "TAG",
  STRIKETHROUGH = "STRIKETHROUGH",
  ESCAPING_CHARACTER = "ESCAPING_CHARACTER",
  MATH = "MATH",
  HIGHLIGHT = "HIGHLIGHT",
  SUBSCRIPT = "SUBSCRIPT",
  SUPERSCRIPT = "SUPERSCRIPT",
  REFERENCED_CONTENT = "REFERENCED_CONTENT",
  SPOILER = "SPOILER",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "NODE_UNSPECIFIED":
      return NodeType.NODE_UNSPECIFIED;
    case 1:
    case "LINE_BREAK":
      return NodeType.LINE_BREAK;
    case 2:
    case "PARAGRAPH":
      return NodeType.PARAGRAPH;
    case 3:
    case "CODE_BLOCK":
      return NodeType.CODE_BLOCK;
    case 4:
    case "HEADING":
      return NodeType.HEADING;
    case 5:
    case "HORIZONTAL_RULE":
      return NodeType.HORIZONTAL_RULE;
    case 6:
    case "BLOCKQUOTE":
      return NodeType.BLOCKQUOTE;
    case 7:
    case "ORDERED_LIST":
      return NodeType.ORDERED_LIST;
    case 8:
    case "UNORDERED_LIST":
      return NodeType.UNORDERED_LIST;
    case 9:
    case "TASK_LIST":
      return NodeType.TASK_LIST;
    case 10:
    case "MATH_BLOCK":
      return NodeType.MATH_BLOCK;
    case 11:
    case "TABLE":
      return NodeType.TABLE;
    case 12:
    case "EMBEDDED_CONTENT":
      return NodeType.EMBEDDED_CONTENT;
    case 13:
    case "TEXT":
      return NodeType.TEXT;
    case 14:
    case "BOLD":
      return NodeType.BOLD;
    case 15:
    case "ITALIC":
      return NodeType.ITALIC;
    case 16:
    case "BOLD_ITALIC":
      return NodeType.BOLD_ITALIC;
    case 17:
    case "CODE":
      return NodeType.CODE;
    case 18:
    case "IMAGE":
      return NodeType.IMAGE;
    case 19:
    case "LINK":
      return NodeType.LINK;
    case 20:
    case "AUTO_LINK":
      return NodeType.AUTO_LINK;
    case 21:
    case "TAG":
      return NodeType.TAG;
    case 22:
    case "STRIKETHROUGH":
      return NodeType.STRIKETHROUGH;
    case 23:
    case "ESCAPING_CHARACTER":
      return NodeType.ESCAPING_CHARACTER;
    case 24:
    case "MATH":
      return NodeType.MATH;
    case 25:
    case "HIGHLIGHT":
      return NodeType.HIGHLIGHT;
    case 26:
    case "SUBSCRIPT":
      return NodeType.SUBSCRIPT;
    case 27:
    case "SUPERSCRIPT":
      return NodeType.SUPERSCRIPT;
    case 28:
    case "REFERENCED_CONTENT":
      return NodeType.REFERENCED_CONTENT;
    case 29:
    case "SPOILER":
      return NodeType.SPOILER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.NODE_UNSPECIFIED:
      return "NODE_UNSPECIFIED";
    case NodeType.LINE_BREAK:
      return "LINE_BREAK";
    case NodeType.PARAGRAPH:
      return "PARAGRAPH";
    case NodeType.CODE_BLOCK:
      return "CODE_BLOCK";
    case NodeType.HEADING:
      return "HEADING";
    case NodeType.HORIZONTAL_RULE:
      return "HORIZONTAL_RULE";
    case NodeType.BLOCKQUOTE:
      return "BLOCKQUOTE";
    case NodeType.ORDERED_LIST:
      return "ORDERED_LIST";
    case NodeType.UNORDERED_LIST:
      return "UNORDERED_LIST";
    case NodeType.TASK_LIST:
      return "TASK_LIST";
    case NodeType.MATH_BLOCK:
      return "MATH_BLOCK";
    case NodeType.TABLE:
      return "TABLE";
    case NodeType.EMBEDDED_CONTENT:
      return "EMBEDDED_CONTENT";
    case NodeType.TEXT:
      return "TEXT";
    case NodeType.BOLD:
      return "BOLD";
    case NodeType.ITALIC:
      return "ITALIC";
    case NodeType.BOLD_ITALIC:
      return "BOLD_ITALIC";
    case NodeType.CODE:
      return "CODE";
    case NodeType.IMAGE:
      return "IMAGE";
    case NodeType.LINK:
      return "LINK";
    case NodeType.AUTO_LINK:
      return "AUTO_LINK";
    case NodeType.TAG:
      return "TAG";
    case NodeType.STRIKETHROUGH:
      return "STRIKETHROUGH";
    case NodeType.ESCAPING_CHARACTER:
      return "ESCAPING_CHARACTER";
    case NodeType.MATH:
      return "MATH";
    case NodeType.HIGHLIGHT:
      return "HIGHLIGHT";
    case NodeType.SUBSCRIPT:
      return "SUBSCRIPT";
    case NodeType.SUPERSCRIPT:
      return "SUPERSCRIPT";
    case NodeType.REFERENCED_CONTENT:
      return "REFERENCED_CONTENT";
    case NodeType.SPOILER:
      return "SPOILER";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function nodeTypeToNumber(object: NodeType): number {
  switch (object) {
    case NodeType.NODE_UNSPECIFIED:
      return 0;
    case NodeType.LINE_BREAK:
      return 1;
    case NodeType.PARAGRAPH:
      return 2;
    case NodeType.CODE_BLOCK:
      return 3;
    case NodeType.HEADING:
      return 4;
    case NodeType.HORIZONTAL_RULE:
      return 5;
    case NodeType.BLOCKQUOTE:
      return 6;
    case NodeType.ORDERED_LIST:
      return 7;
    case NodeType.UNORDERED_LIST:
      return 8;
    case NodeType.TASK_LIST:
      return 9;
    case NodeType.MATH_BLOCK:
      return 10;
    case NodeType.TABLE:
      return 11;
    case NodeType.EMBEDDED_CONTENT:
      return 12;
    case NodeType.TEXT:
      return 13;
    case NodeType.BOLD:
      return 14;
    case NodeType.ITALIC:
      return 15;
    case NodeType.BOLD_ITALIC:
      return 16;
    case NodeType.CODE:
      return 17;
    case NodeType.IMAGE:
      return 18;
    case NodeType.LINK:
      return 19;
    case NodeType.AUTO_LINK:
      return 20;
    case NodeType.TAG:
      return 21;
    case NodeType.STRIKETHROUGH:
      return 22;
    case NodeType.ESCAPING_CHARACTER:
      return 23;
    case NodeType.MATH:
      return 24;
    case NodeType.HIGHLIGHT:
      return 25;
    case NodeType.SUBSCRIPT:
      return 26;
    case NodeType.SUPERSCRIPT:
      return 27;
    case NodeType.REFERENCED_CONTENT:
      return 28;
    case NodeType.SPOILER:
      return 29;
    case NodeType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface ParseMarkdownRequest {
  markdown: string;
}

export interface ParseMarkdownResponse {
  nodes: Node[];
}

export interface RestoreMarkdownRequest {
  nodes: Node[];
}

export interface RestoreMarkdownResponse {
  markdown: string;
}

export interface GetLinkMetadataRequest {
  link: string;
}

export interface LinkMetadata {
  title: string;
  description: string;
  image: string;
}

export interface Node {
  type: NodeType;
  node?:
    | //
    { $case: "lineBreakNode"; lineBreakNode: LineBreakNode }
    | //
    { $case: "paragraphNode"; paragraphNode: ParagraphNode }
    | //
    { $case: "codeBlockNode"; codeBlockNode: CodeBlockNode }
    | //
    { $case: "headingNode"; headingNode: HeadingNode }
    | //
    { $case: "horizontalRuleNode"; horizontalRuleNode: HorizontalRuleNode }
    | //
    { $case: "blockquoteNode"; blockquoteNode: BlockquoteNode }
    | //
    { $case: "orderedListNode"; orderedListNode: OrderedListNode }
    | //
    { $case: "unorderedListNode"; unorderedListNode: UnorderedListNode }
    | //
    { $case: "taskListNode"; taskListNode: TaskListNode }
    | //
    { $case: "mathBlockNode"; mathBlockNode: MathBlockNode }
    | //
    { $case: "tableNode"; tableNode: TableNode }
    | //
    { $case: "embeddedContentNode"; embeddedContentNode: EmbeddedContentNode }
    | //
    { $case: "textNode"; textNode: TextNode }
    | //
    { $case: "boldNode"; boldNode: BoldNode }
    | //
    { $case: "italicNode"; italicNode: ItalicNode }
    | //
    { $case: "boldItalicNode"; boldItalicNode: BoldItalicNode }
    | //
    { $case: "codeNode"; codeNode: CodeNode }
    | //
    { $case: "imageNode"; imageNode: ImageNode }
    | //
    { $case: "linkNode"; linkNode: LinkNode }
    | //
    { $case: "autoLinkNode"; autoLinkNode: AutoLinkNode }
    | //
    { $case: "tagNode"; tagNode: TagNode }
    | //
    { $case: "strikethroughNode"; strikethroughNode: StrikethroughNode }
    | //
    { $case: "escapingCharacterNode"; escapingCharacterNode: EscapingCharacterNode }
    | //
    { $case: "mathNode"; mathNode: MathNode }
    | //
    { $case: "highlightNode"; highlightNode: HighlightNode }
    | //
    { $case: "subscriptNode"; subscriptNode: SubscriptNode }
    | //
    { $case: "superscriptNode"; superscriptNode: SuperscriptNode }
    | //
    { $case: "referencedContentNode"; referencedContentNode: ReferencedContentNode }
    | //
    { $case: "spoilerNode"; spoilerNode: SpoilerNode }
    | undefined;
}

export interface LineBreakNode {
}

export interface ParagraphNode {
  children: Node[];
}

export interface CodeBlockNode {
  language: string;
  content: string;
}

export interface HeadingNode {
  level: number;
  children: Node[];
}

export interface HorizontalRuleNode {
  symbol: string;
}

export interface BlockquoteNode {
  children: Node[];
}

export interface OrderedListNode {
  number: string;
  indent: number;
  children: Node[];
}

export interface UnorderedListNode {
  symbol: string;
  indent: number;
  children: Node[];
}

export interface TaskListNode {
  symbol: string;
  indent: number;
  complete: boolean;
  children: Node[];
}

export interface MathBlockNode {
  content: string;
}

export interface TableNode {
  header: string[];
  delimiter: string[];
  rows: TableNode_Row[];
}

export interface TableNode_Row {
  cells: string[];
}

export interface EmbeddedContentNode {
  resourceName: string;
  params: string;
}

export interface TextNode {
  content: string;
}

export interface BoldNode {
  symbol: string;
  children: Node[];
}

export interface ItalicNode {
  symbol: string;
  content: string;
}

export interface BoldItalicNode {
  symbol: string;
  content: string;
}

export interface CodeNode {
  content: string;
}

export interface ImageNode {
  altText: string;
  url: string;
}

export interface LinkNode {
  text: string;
  url: string;
}

export interface AutoLinkNode {
  url: string;
  isRawText: boolean;
}

export interface TagNode {
  content: string;
}

export interface StrikethroughNode {
  content: string;
}

export interface EscapingCharacterNode {
  symbol: string;
}

export interface MathNode {
  content: string;
}

export interface HighlightNode {
  content: string;
}

export interface SubscriptNode {
  content: string;
}

export interface SuperscriptNode {
  content: string;
}

export interface ReferencedContentNode {
  resourceName: string;
  params: string;
}

export interface SpoilerNode {
  content: string;
}

function createBaseParseMarkdownRequest(): ParseMarkdownRequest {
  return { markdown: "" };
}

export const ParseMarkdownRequest: MessageFns<ParseMarkdownRequest> = {
  encode(message: ParseMarkdownRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markdown !== "") {
      writer.uint32(10).string(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseMarkdownRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseMarkdownRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markdown = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseMarkdownRequest {
    return { markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : "" };
  },

  toJSON(message: ParseMarkdownRequest): unknown {
    const obj: any = {};
    if (message.markdown !== "") {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create(base?: DeepPartial<ParseMarkdownRequest>): ParseMarkdownRequest {
    return ParseMarkdownRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseMarkdownRequest>): ParseMarkdownRequest {
    const message = createBaseParseMarkdownRequest();
    message.markdown = object.markdown ?? "";
    return message;
  },
};

function createBaseParseMarkdownResponse(): ParseMarkdownResponse {
  return { nodes: [] };
}

export const ParseMarkdownResponse: MessageFns<ParseMarkdownResponse> = {
  encode(message: ParseMarkdownResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParseMarkdownResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParseMarkdownResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParseMarkdownResponse {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: ParseMarkdownResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParseMarkdownResponse>): ParseMarkdownResponse {
    return ParseMarkdownResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParseMarkdownResponse>): ParseMarkdownResponse {
    const message = createBaseParseMarkdownResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRestoreMarkdownRequest(): RestoreMarkdownRequest {
  return { nodes: [] };
}

export const RestoreMarkdownRequest: MessageFns<RestoreMarkdownRequest> = {
  encode(message: RestoreMarkdownRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreMarkdownRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreMarkdownRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreMarkdownRequest {
    return { nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [] };
  },

  toJSON(message: RestoreMarkdownRequest): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreMarkdownRequest>): RestoreMarkdownRequest {
    return RestoreMarkdownRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreMarkdownRequest>): RestoreMarkdownRequest {
    const message = createBaseRestoreMarkdownRequest();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRestoreMarkdownResponse(): RestoreMarkdownResponse {
  return { markdown: "" };
}

export const RestoreMarkdownResponse: MessageFns<RestoreMarkdownResponse> = {
  encode(message: RestoreMarkdownResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markdown !== "") {
      writer.uint32(10).string(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreMarkdownResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreMarkdownResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markdown = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreMarkdownResponse {
    return { markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : "" };
  },

  toJSON(message: RestoreMarkdownResponse): unknown {
    const obj: any = {};
    if (message.markdown !== "") {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreMarkdownResponse>): RestoreMarkdownResponse {
    return RestoreMarkdownResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreMarkdownResponse>): RestoreMarkdownResponse {
    const message = createBaseRestoreMarkdownResponse();
    message.markdown = object.markdown ?? "";
    return message;
  },
};

function createBaseGetLinkMetadataRequest(): GetLinkMetadataRequest {
  return { link: "" };
}

export const GetLinkMetadataRequest: MessageFns<GetLinkMetadataRequest> = {
  encode(message: GetLinkMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.link !== "") {
      writer.uint32(10).string(message.link);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLinkMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLinkMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.link = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLinkMetadataRequest {
    return { link: isSet(object.link) ? globalThis.String(object.link) : "" };
  },

  toJSON(message: GetLinkMetadataRequest): unknown {
    const obj: any = {};
    if (message.link !== "") {
      obj.link = message.link;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLinkMetadataRequest>): GetLinkMetadataRequest {
    return GetLinkMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLinkMetadataRequest>): GetLinkMetadataRequest {
    const message = createBaseGetLinkMetadataRequest();
    message.link = object.link ?? "";
    return message;
  },
};

function createBaseLinkMetadata(): LinkMetadata {
  return { title: "", description: "", image: "" };
}

export const LinkMetadata: MessageFns<LinkMetadata> = {
  encode(message: LinkMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkMetadata {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
    };
  },

  toJSON(message: LinkMetadata): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    return obj;
  },

  create(base?: DeepPartial<LinkMetadata>): LinkMetadata {
    return LinkMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinkMetadata>): LinkMetadata {
    const message = createBaseLinkMetadata();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.image = object.image ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return { type: NodeType.NODE_UNSPECIFIED, node: undefined };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== NodeType.NODE_UNSPECIFIED) {
      writer.uint32(8).int32(nodeTypeToNumber(message.type));
    }
    switch (message.node?.$case) {
      case "lineBreakNode":
        LineBreakNode.encode(message.node.lineBreakNode, writer.uint32(18).fork()).join();
        break;
      case "paragraphNode":
        ParagraphNode.encode(message.node.paragraphNode, writer.uint32(26).fork()).join();
        break;
      case "codeBlockNode":
        CodeBlockNode.encode(message.node.codeBlockNode, writer.uint32(34).fork()).join();
        break;
      case "headingNode":
        HeadingNode.encode(message.node.headingNode, writer.uint32(42).fork()).join();
        break;
      case "horizontalRuleNode":
        HorizontalRuleNode.encode(message.node.horizontalRuleNode, writer.uint32(50).fork()).join();
        break;
      case "blockquoteNode":
        BlockquoteNode.encode(message.node.blockquoteNode, writer.uint32(58).fork()).join();
        break;
      case "orderedListNode":
        OrderedListNode.encode(message.node.orderedListNode, writer.uint32(66).fork()).join();
        break;
      case "unorderedListNode":
        UnorderedListNode.encode(message.node.unorderedListNode, writer.uint32(74).fork()).join();
        break;
      case "taskListNode":
        TaskListNode.encode(message.node.taskListNode, writer.uint32(82).fork()).join();
        break;
      case "mathBlockNode":
        MathBlockNode.encode(message.node.mathBlockNode, writer.uint32(90).fork()).join();
        break;
      case "tableNode":
        TableNode.encode(message.node.tableNode, writer.uint32(98).fork()).join();
        break;
      case "embeddedContentNode":
        EmbeddedContentNode.encode(message.node.embeddedContentNode, writer.uint32(106).fork()).join();
        break;
      case "textNode":
        TextNode.encode(message.node.textNode, writer.uint32(114).fork()).join();
        break;
      case "boldNode":
        BoldNode.encode(message.node.boldNode, writer.uint32(122).fork()).join();
        break;
      case "italicNode":
        ItalicNode.encode(message.node.italicNode, writer.uint32(130).fork()).join();
        break;
      case "boldItalicNode":
        BoldItalicNode.encode(message.node.boldItalicNode, writer.uint32(138).fork()).join();
        break;
      case "codeNode":
        CodeNode.encode(message.node.codeNode, writer.uint32(146).fork()).join();
        break;
      case "imageNode":
        ImageNode.encode(message.node.imageNode, writer.uint32(154).fork()).join();
        break;
      case "linkNode":
        LinkNode.encode(message.node.linkNode, writer.uint32(162).fork()).join();
        break;
      case "autoLinkNode":
        AutoLinkNode.encode(message.node.autoLinkNode, writer.uint32(170).fork()).join();
        break;
      case "tagNode":
        TagNode.encode(message.node.tagNode, writer.uint32(178).fork()).join();
        break;
      case "strikethroughNode":
        StrikethroughNode.encode(message.node.strikethroughNode, writer.uint32(186).fork()).join();
        break;
      case "escapingCharacterNode":
        EscapingCharacterNode.encode(message.node.escapingCharacterNode, writer.uint32(194).fork()).join();
        break;
      case "mathNode":
        MathNode.encode(message.node.mathNode, writer.uint32(202).fork()).join();
        break;
      case "highlightNode":
        HighlightNode.encode(message.node.highlightNode, writer.uint32(210).fork()).join();
        break;
      case "subscriptNode":
        SubscriptNode.encode(message.node.subscriptNode, writer.uint32(218).fork()).join();
        break;
      case "superscriptNode":
        SuperscriptNode.encode(message.node.superscriptNode, writer.uint32(226).fork()).join();
        break;
      case "referencedContentNode":
        ReferencedContentNode.encode(message.node.referencedContentNode, writer.uint32(234).fork()).join();
        break;
      case "spoilerNode":
        SpoilerNode.encode(message.node.spoilerNode, writer.uint32(242).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = nodeTypeFromJSON(reader.int32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.node = { $case: "lineBreakNode", lineBreakNode: LineBreakNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.node = { $case: "paragraphNode", paragraphNode: ParagraphNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.node = { $case: "codeBlockNode", codeBlockNode: CodeBlockNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.node = { $case: "headingNode", headingNode: HeadingNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.node = {
            $case: "horizontalRuleNode",
            horizontalRuleNode: HorizontalRuleNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.node = { $case: "blockquoteNode", blockquoteNode: BlockquoteNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.node = { $case: "orderedListNode", orderedListNode: OrderedListNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.node = {
            $case: "unorderedListNode",
            unorderedListNode: UnorderedListNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.node = { $case: "taskListNode", taskListNode: TaskListNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.node = { $case: "mathBlockNode", mathBlockNode: MathBlockNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.node = { $case: "tableNode", tableNode: TableNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.node = {
            $case: "embeddedContentNode",
            embeddedContentNode: EmbeddedContentNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.node = { $case: "textNode", textNode: TextNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.node = { $case: "boldNode", boldNode: BoldNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.node = { $case: "italicNode", italicNode: ItalicNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.node = { $case: "boldItalicNode", boldItalicNode: BoldItalicNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.node = { $case: "codeNode", codeNode: CodeNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.node = { $case: "imageNode", imageNode: ImageNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.node = { $case: "linkNode", linkNode: LinkNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.node = { $case: "autoLinkNode", autoLinkNode: AutoLinkNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.node = { $case: "tagNode", tagNode: TagNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.node = {
            $case: "strikethroughNode",
            strikethroughNode: StrikethroughNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.node = {
            $case: "escapingCharacterNode",
            escapingCharacterNode: EscapingCharacterNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.node = { $case: "mathNode", mathNode: MathNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.node = { $case: "highlightNode", highlightNode: HighlightNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.node = { $case: "subscriptNode", subscriptNode: SubscriptNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.node = { $case: "superscriptNode", superscriptNode: SuperscriptNode.decode(reader, reader.uint32()) };
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.node = {
            $case: "referencedContentNode",
            referencedContentNode: ReferencedContentNode.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.node = { $case: "spoilerNode", spoilerNode: SpoilerNode.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      type: isSet(object.type) ? nodeTypeFromJSON(object.type) : NodeType.NODE_UNSPECIFIED,
      node: isSet(object.lineBreakNode)
        ? { $case: "lineBreakNode", lineBreakNode: LineBreakNode.fromJSON(object.lineBreakNode) }
        : isSet(object.paragraphNode)
        ? { $case: "paragraphNode", paragraphNode: ParagraphNode.fromJSON(object.paragraphNode) }
        : isSet(object.codeBlockNode)
        ? { $case: "codeBlockNode", codeBlockNode: CodeBlockNode.fromJSON(object.codeBlockNode) }
        : isSet(object.headingNode)
        ? { $case: "headingNode", headingNode: HeadingNode.fromJSON(object.headingNode) }
        : isSet(object.horizontalRuleNode)
        ? { $case: "horizontalRuleNode", horizontalRuleNode: HorizontalRuleNode.fromJSON(object.horizontalRuleNode) }
        : isSet(object.blockquoteNode)
        ? { $case: "blockquoteNode", blockquoteNode: BlockquoteNode.fromJSON(object.blockquoteNode) }
        : isSet(object.orderedListNode)
        ? { $case: "orderedListNode", orderedListNode: OrderedListNode.fromJSON(object.orderedListNode) }
        : isSet(object.unorderedListNode)
        ? { $case: "unorderedListNode", unorderedListNode: UnorderedListNode.fromJSON(object.unorderedListNode) }
        : isSet(object.taskListNode)
        ? { $case: "taskListNode", taskListNode: TaskListNode.fromJSON(object.taskListNode) }
        : isSet(object.mathBlockNode)
        ? { $case: "mathBlockNode", mathBlockNode: MathBlockNode.fromJSON(object.mathBlockNode) }
        : isSet(object.tableNode)
        ? { $case: "tableNode", tableNode: TableNode.fromJSON(object.tableNode) }
        : isSet(object.embeddedContentNode)
        ? {
          $case: "embeddedContentNode",
          embeddedContentNode: EmbeddedContentNode.fromJSON(object.embeddedContentNode),
        }
        : isSet(object.textNode)
        ? { $case: "textNode", textNode: TextNode.fromJSON(object.textNode) }
        : isSet(object.boldNode)
        ? { $case: "boldNode", boldNode: BoldNode.fromJSON(object.boldNode) }
        : isSet(object.italicNode)
        ? { $case: "italicNode", italicNode: ItalicNode.fromJSON(object.italicNode) }
        : isSet(object.boldItalicNode)
        ? { $case: "boldItalicNode", boldItalicNode: BoldItalicNode.fromJSON(object.boldItalicNode) }
        : isSet(object.codeNode)
        ? { $case: "codeNode", codeNode: CodeNode.fromJSON(object.codeNode) }
        : isSet(object.imageNode)
        ? { $case: "imageNode", imageNode: ImageNode.fromJSON(object.imageNode) }
        : isSet(object.linkNode)
        ? { $case: "linkNode", linkNode: LinkNode.fromJSON(object.linkNode) }
        : isSet(object.autoLinkNode)
        ? { $case: "autoLinkNode", autoLinkNode: AutoLinkNode.fromJSON(object.autoLinkNode) }
        : isSet(object.tagNode)
        ? { $case: "tagNode", tagNode: TagNode.fromJSON(object.tagNode) }
        : isSet(object.strikethroughNode)
        ? { $case: "strikethroughNode", strikethroughNode: StrikethroughNode.fromJSON(object.strikethroughNode) }
        : isSet(object.escapingCharacterNode)
        ? {
          $case: "escapingCharacterNode",
          escapingCharacterNode: EscapingCharacterNode.fromJSON(object.escapingCharacterNode),
        }
        : isSet(object.mathNode)
        ? { $case: "mathNode", mathNode: MathNode.fromJSON(object.mathNode) }
        : isSet(object.highlightNode)
        ? { $case: "highlightNode", highlightNode: HighlightNode.fromJSON(object.highlightNode) }
        : isSet(object.subscriptNode)
        ? { $case: "subscriptNode", subscriptNode: SubscriptNode.fromJSON(object.subscriptNode) }
        : isSet(object.superscriptNode)
        ? { $case: "superscriptNode", superscriptNode: SuperscriptNode.fromJSON(object.superscriptNode) }
        : isSet(object.referencedContentNode)
        ? {
          $case: "referencedContentNode",
          referencedContentNode: ReferencedContentNode.fromJSON(object.referencedContentNode),
        }
        : isSet(object.spoilerNode)
        ? { $case: "spoilerNode", spoilerNode: SpoilerNode.fromJSON(object.spoilerNode) }
        : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.type !== NodeType.NODE_UNSPECIFIED) {
      obj.type = nodeTypeToJSON(message.type);
    }
    if (message.node?.$case === "lineBreakNode") {
      obj.lineBreakNode = LineBreakNode.toJSON(message.node.lineBreakNode);
    }
    if (message.node?.$case === "paragraphNode") {
      obj.paragraphNode = ParagraphNode.toJSON(message.node.paragraphNode);
    }
    if (message.node?.$case === "codeBlockNode") {
      obj.codeBlockNode = CodeBlockNode.toJSON(message.node.codeBlockNode);
    }
    if (message.node?.$case === "headingNode") {
      obj.headingNode = HeadingNode.toJSON(message.node.headingNode);
    }
    if (message.node?.$case === "horizontalRuleNode") {
      obj.horizontalRuleNode = HorizontalRuleNode.toJSON(message.node.horizontalRuleNode);
    }
    if (message.node?.$case === "blockquoteNode") {
      obj.blockquoteNode = BlockquoteNode.toJSON(message.node.blockquoteNode);
    }
    if (message.node?.$case === "orderedListNode") {
      obj.orderedListNode = OrderedListNode.toJSON(message.node.orderedListNode);
    }
    if (message.node?.$case === "unorderedListNode") {
      obj.unorderedListNode = UnorderedListNode.toJSON(message.node.unorderedListNode);
    }
    if (message.node?.$case === "taskListNode") {
      obj.taskListNode = TaskListNode.toJSON(message.node.taskListNode);
    }
    if (message.node?.$case === "mathBlockNode") {
      obj.mathBlockNode = MathBlockNode.toJSON(message.node.mathBlockNode);
    }
    if (message.node?.$case === "tableNode") {
      obj.tableNode = TableNode.toJSON(message.node.tableNode);
    }
    if (message.node?.$case === "embeddedContentNode") {
      obj.embeddedContentNode = EmbeddedContentNode.toJSON(message.node.embeddedContentNode);
    }
    if (message.node?.$case === "textNode") {
      obj.textNode = TextNode.toJSON(message.node.textNode);
    }
    if (message.node?.$case === "boldNode") {
      obj.boldNode = BoldNode.toJSON(message.node.boldNode);
    }
    if (message.node?.$case === "italicNode") {
      obj.italicNode = ItalicNode.toJSON(message.node.italicNode);
    }
    if (message.node?.$case === "boldItalicNode") {
      obj.boldItalicNode = BoldItalicNode.toJSON(message.node.boldItalicNode);
    }
    if (message.node?.$case === "codeNode") {
      obj.codeNode = CodeNode.toJSON(message.node.codeNode);
    }
    if (message.node?.$case === "imageNode") {
      obj.imageNode = ImageNode.toJSON(message.node.imageNode);
    }
    if (message.node?.$case === "linkNode") {
      obj.linkNode = LinkNode.toJSON(message.node.linkNode);
    }
    if (message.node?.$case === "autoLinkNode") {
      obj.autoLinkNode = AutoLinkNode.toJSON(message.node.autoLinkNode);
    }
    if (message.node?.$case === "tagNode") {
      obj.tagNode = TagNode.toJSON(message.node.tagNode);
    }
    if (message.node?.$case === "strikethroughNode") {
      obj.strikethroughNode = StrikethroughNode.toJSON(message.node.strikethroughNode);
    }
    if (message.node?.$case === "escapingCharacterNode") {
      obj.escapingCharacterNode = EscapingCharacterNode.toJSON(message.node.escapingCharacterNode);
    }
    if (message.node?.$case === "mathNode") {
      obj.mathNode = MathNode.toJSON(message.node.mathNode);
    }
    if (message.node?.$case === "highlightNode") {
      obj.highlightNode = HighlightNode.toJSON(message.node.highlightNode);
    }
    if (message.node?.$case === "subscriptNode") {
      obj.subscriptNode = SubscriptNode.toJSON(message.node.subscriptNode);
    }
    if (message.node?.$case === "superscriptNode") {
      obj.superscriptNode = SuperscriptNode.toJSON(message.node.superscriptNode);
    }
    if (message.node?.$case === "referencedContentNode") {
      obj.referencedContentNode = ReferencedContentNode.toJSON(message.node.referencedContentNode);
    }
    if (message.node?.$case === "spoilerNode") {
      obj.spoilerNode = SpoilerNode.toJSON(message.node.spoilerNode);
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.type = object.type ?? NodeType.NODE_UNSPECIFIED;
    if (
      object.node?.$case === "lineBreakNode" &&
      object.node?.lineBreakNode !== undefined &&
      object.node?.lineBreakNode !== null
    ) {
      message.node = { $case: "lineBreakNode", lineBreakNode: LineBreakNode.fromPartial(object.node.lineBreakNode) };
    }
    if (
      object.node?.$case === "paragraphNode" &&
      object.node?.paragraphNode !== undefined &&
      object.node?.paragraphNode !== null
    ) {
      message.node = { $case: "paragraphNode", paragraphNode: ParagraphNode.fromPartial(object.node.paragraphNode) };
    }
    if (
      object.node?.$case === "codeBlockNode" &&
      object.node?.codeBlockNode !== undefined &&
      object.node?.codeBlockNode !== null
    ) {
      message.node = { $case: "codeBlockNode", codeBlockNode: CodeBlockNode.fromPartial(object.node.codeBlockNode) };
    }
    if (
      object.node?.$case === "headingNode" &&
      object.node?.headingNode !== undefined &&
      object.node?.headingNode !== null
    ) {
      message.node = { $case: "headingNode", headingNode: HeadingNode.fromPartial(object.node.headingNode) };
    }
    if (
      object.node?.$case === "horizontalRuleNode" &&
      object.node?.horizontalRuleNode !== undefined &&
      object.node?.horizontalRuleNode !== null
    ) {
      message.node = {
        $case: "horizontalRuleNode",
        horizontalRuleNode: HorizontalRuleNode.fromPartial(object.node.horizontalRuleNode),
      };
    }
    if (
      object.node?.$case === "blockquoteNode" &&
      object.node?.blockquoteNode !== undefined &&
      object.node?.blockquoteNode !== null
    ) {
      message.node = {
        $case: "blockquoteNode",
        blockquoteNode: BlockquoteNode.fromPartial(object.node.blockquoteNode),
      };
    }
    if (
      object.node?.$case === "orderedListNode" &&
      object.node?.orderedListNode !== undefined &&
      object.node?.orderedListNode !== null
    ) {
      message.node = {
        $case: "orderedListNode",
        orderedListNode: OrderedListNode.fromPartial(object.node.orderedListNode),
      };
    }
    if (
      object.node?.$case === "unorderedListNode" &&
      object.node?.unorderedListNode !== undefined &&
      object.node?.unorderedListNode !== null
    ) {
      message.node = {
        $case: "unorderedListNode",
        unorderedListNode: UnorderedListNode.fromPartial(object.node.unorderedListNode),
      };
    }
    if (
      object.node?.$case === "taskListNode" &&
      object.node?.taskListNode !== undefined &&
      object.node?.taskListNode !== null
    ) {
      message.node = { $case: "taskListNode", taskListNode: TaskListNode.fromPartial(object.node.taskListNode) };
    }
    if (
      object.node?.$case === "mathBlockNode" &&
      object.node?.mathBlockNode !== undefined &&
      object.node?.mathBlockNode !== null
    ) {
      message.node = { $case: "mathBlockNode", mathBlockNode: MathBlockNode.fromPartial(object.node.mathBlockNode) };
    }
    if (object.node?.$case === "tableNode" && object.node?.tableNode !== undefined && object.node?.tableNode !== null) {
      message.node = { $case: "tableNode", tableNode: TableNode.fromPartial(object.node.tableNode) };
    }
    if (
      object.node?.$case === "embeddedContentNode" &&
      object.node?.embeddedContentNode !== undefined &&
      object.node?.embeddedContentNode !== null
    ) {
      message.node = {
        $case: "embeddedContentNode",
        embeddedContentNode: EmbeddedContentNode.fromPartial(object.node.embeddedContentNode),
      };
    }
    if (object.node?.$case === "textNode" && object.node?.textNode !== undefined && object.node?.textNode !== null) {
      message.node = { $case: "textNode", textNode: TextNode.fromPartial(object.node.textNode) };
    }
    if (object.node?.$case === "boldNode" && object.node?.boldNode !== undefined && object.node?.boldNode !== null) {
      message.node = { $case: "boldNode", boldNode: BoldNode.fromPartial(object.node.boldNode) };
    }
    if (
      object.node?.$case === "italicNode" && object.node?.italicNode !== undefined && object.node?.italicNode !== null
    ) {
      message.node = { $case: "italicNode", italicNode: ItalicNode.fromPartial(object.node.italicNode) };
    }
    if (
      object.node?.$case === "boldItalicNode" &&
      object.node?.boldItalicNode !== undefined &&
      object.node?.boldItalicNode !== null
    ) {
      message.node = {
        $case: "boldItalicNode",
        boldItalicNode: BoldItalicNode.fromPartial(object.node.boldItalicNode),
      };
    }
    if (object.node?.$case === "codeNode" && object.node?.codeNode !== undefined && object.node?.codeNode !== null) {
      message.node = { $case: "codeNode", codeNode: CodeNode.fromPartial(object.node.codeNode) };
    }
    if (object.node?.$case === "imageNode" && object.node?.imageNode !== undefined && object.node?.imageNode !== null) {
      message.node = { $case: "imageNode", imageNode: ImageNode.fromPartial(object.node.imageNode) };
    }
    if (object.node?.$case === "linkNode" && object.node?.linkNode !== undefined && object.node?.linkNode !== null) {
      message.node = { $case: "linkNode", linkNode: LinkNode.fromPartial(object.node.linkNode) };
    }
    if (
      object.node?.$case === "autoLinkNode" &&
      object.node?.autoLinkNode !== undefined &&
      object.node?.autoLinkNode !== null
    ) {
      message.node = { $case: "autoLinkNode", autoLinkNode: AutoLinkNode.fromPartial(object.node.autoLinkNode) };
    }
    if (object.node?.$case === "tagNode" && object.node?.tagNode !== undefined && object.node?.tagNode !== null) {
      message.node = { $case: "tagNode", tagNode: TagNode.fromPartial(object.node.tagNode) };
    }
    if (
      object.node?.$case === "strikethroughNode" &&
      object.node?.strikethroughNode !== undefined &&
      object.node?.strikethroughNode !== null
    ) {
      message.node = {
        $case: "strikethroughNode",
        strikethroughNode: StrikethroughNode.fromPartial(object.node.strikethroughNode),
      };
    }
    if (
      object.node?.$case === "escapingCharacterNode" &&
      object.node?.escapingCharacterNode !== undefined &&
      object.node?.escapingCharacterNode !== null
    ) {
      message.node = {
        $case: "escapingCharacterNode",
        escapingCharacterNode: EscapingCharacterNode.fromPartial(object.node.escapingCharacterNode),
      };
    }
    if (object.node?.$case === "mathNode" && object.node?.mathNode !== undefined && object.node?.mathNode !== null) {
      message.node = { $case: "mathNode", mathNode: MathNode.fromPartial(object.node.mathNode) };
    }
    if (
      object.node?.$case === "highlightNode" &&
      object.node?.highlightNode !== undefined &&
      object.node?.highlightNode !== null
    ) {
      message.node = { $case: "highlightNode", highlightNode: HighlightNode.fromPartial(object.node.highlightNode) };
    }
    if (
      object.node?.$case === "subscriptNode" &&
      object.node?.subscriptNode !== undefined &&
      object.node?.subscriptNode !== null
    ) {
      message.node = { $case: "subscriptNode", subscriptNode: SubscriptNode.fromPartial(object.node.subscriptNode) };
    }
    if (
      object.node?.$case === "superscriptNode" &&
      object.node?.superscriptNode !== undefined &&
      object.node?.superscriptNode !== null
    ) {
      message.node = {
        $case: "superscriptNode",
        superscriptNode: SuperscriptNode.fromPartial(object.node.superscriptNode),
      };
    }
    if (
      object.node?.$case === "referencedContentNode" &&
      object.node?.referencedContentNode !== undefined &&
      object.node?.referencedContentNode !== null
    ) {
      message.node = {
        $case: "referencedContentNode",
        referencedContentNode: ReferencedContentNode.fromPartial(object.node.referencedContentNode),
      };
    }
    if (
      object.node?.$case === "spoilerNode" &&
      object.node?.spoilerNode !== undefined &&
      object.node?.spoilerNode !== null
    ) {
      message.node = { $case: "spoilerNode", spoilerNode: SpoilerNode.fromPartial(object.node.spoilerNode) };
    }
    return message;
  },
};

function createBaseLineBreakNode(): LineBreakNode {
  return {};
}

export const LineBreakNode: MessageFns<LineBreakNode> = {
  encode(_: LineBreakNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineBreakNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineBreakNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LineBreakNode {
    return {};
  },

  toJSON(_: LineBreakNode): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LineBreakNode>): LineBreakNode {
    return LineBreakNode.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LineBreakNode>): LineBreakNode {
    const message = createBaseLineBreakNode();
    return message;
  },
};

function createBaseParagraphNode(): ParagraphNode {
  return { children: [] };
}

export const ParagraphNode: MessageFns<ParagraphNode> = {
  encode(message: ParagraphNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParagraphNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParagraphNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParagraphNode {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: ParagraphNode): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParagraphNode>): ParagraphNode {
    return ParagraphNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParagraphNode>): ParagraphNode {
    const message = createBaseParagraphNode();
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCodeBlockNode(): CodeBlockNode {
  return { language: "", content: "" };
}

export const CodeBlockNode: MessageFns<CodeBlockNode> = {
  encode(message: CodeBlockNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeBlockNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeBlockNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeBlockNode {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: CodeBlockNode): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<CodeBlockNode>): CodeBlockNode {
    return CodeBlockNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CodeBlockNode>): CodeBlockNode {
    const message = createBaseCodeBlockNode();
    message.language = object.language ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseHeadingNode(): HeadingNode {
  return { level: 0, children: [] };
}

export const HeadingNode: MessageFns<HeadingNode> = {
  encode(message: HeadingNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeadingNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeadingNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeadingNode {
    return {
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: HeadingNode): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HeadingNode>): HeadingNode {
    return HeadingNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HeadingNode>): HeadingNode {
    const message = createBaseHeadingNode();
    message.level = object.level ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHorizontalRuleNode(): HorizontalRuleNode {
  return { symbol: "" };
}

export const HorizontalRuleNode: MessageFns<HorizontalRuleNode> = {
  encode(message: HorizontalRuleNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HorizontalRuleNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHorizontalRuleNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HorizontalRuleNode {
    return { symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "" };
  },

  toJSON(message: HorizontalRuleNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create(base?: DeepPartial<HorizontalRuleNode>): HorizontalRuleNode {
    return HorizontalRuleNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HorizontalRuleNode>): HorizontalRuleNode {
    const message = createBaseHorizontalRuleNode();
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseBlockquoteNode(): BlockquoteNode {
  return { children: [] };
}

export const BlockquoteNode: MessageFns<BlockquoteNode> = {
  encode(message: BlockquoteNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockquoteNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockquoteNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockquoteNode {
    return {
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: BlockquoteNode): unknown {
    const obj: any = {};
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BlockquoteNode>): BlockquoteNode {
    return BlockquoteNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockquoteNode>): BlockquoteNode {
    const message = createBaseBlockquoteNode();
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderedListNode(): OrderedListNode {
  return { number: "", indent: 0, children: [] };
}

export const OrderedListNode: MessageFns<OrderedListNode> = {
  encode(message: OrderedListNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== "") {
      writer.uint32(10).string(message.number);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderedListNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderedListNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderedListNode {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: OrderedListNode): unknown {
    const obj: any = {};
    if (message.number !== "") {
      obj.number = message.number;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OrderedListNode>): OrderedListNode {
    return OrderedListNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderedListNode>): OrderedListNode {
    const message = createBaseOrderedListNode();
    message.number = object.number ?? "";
    message.indent = object.indent ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnorderedListNode(): UnorderedListNode {
  return { symbol: "", indent: 0, children: [] };
}

export const UnorderedListNode: MessageFns<UnorderedListNode> = {
  encode(message: UnorderedListNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnorderedListNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnorderedListNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnorderedListNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: UnorderedListNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UnorderedListNode>): UnorderedListNode {
    return UnorderedListNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnorderedListNode>): UnorderedListNode {
    const message = createBaseUnorderedListNode();
    message.symbol = object.symbol ?? "";
    message.indent = object.indent ?? 0;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskListNode(): TaskListNode {
  return { symbol: "", indent: 0, complete: false, children: [] };
}

export const TaskListNode: MessageFns<TaskListNode> = {
  encode(message: TaskListNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.indent !== 0) {
      writer.uint32(16).int32(message.indent);
    }
    if (message.complete !== false) {
      writer.uint32(24).bool(message.complete);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskListNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskListNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.indent = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.complete = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskListNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      indent: isSet(object.indent) ? globalThis.Number(object.indent) : 0,
      complete: isSet(object.complete) ? globalThis.Boolean(object.complete) : false,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: TaskListNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.indent !== 0) {
      obj.indent = Math.round(message.indent);
    }
    if (message.complete !== false) {
      obj.complete = message.complete;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskListNode>): TaskListNode {
    return TaskListNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskListNode>): TaskListNode {
    const message = createBaseTaskListNode();
    message.symbol = object.symbol ?? "";
    message.indent = object.indent ?? 0;
    message.complete = object.complete ?? false;
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMathBlockNode(): MathBlockNode {
  return { content: "" };
}

export const MathBlockNode: MessageFns<MathBlockNode> = {
  encode(message: MathBlockNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MathBlockNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMathBlockNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MathBlockNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: MathBlockNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<MathBlockNode>): MathBlockNode {
    return MathBlockNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MathBlockNode>): MathBlockNode {
    const message = createBaseMathBlockNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseTableNode(): TableNode {
  return { header: [], delimiter: [], rows: [] };
}

export const TableNode: MessageFns<TableNode> = {
  encode(message: TableNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.header) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.delimiter) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.rows) {
      TableNode_Row.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delimiter.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rows.push(TableNode_Row.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableNode {
    return {
      header: globalThis.Array.isArray(object?.header) ? object.header.map((e: any) => globalThis.String(e)) : [],
      delimiter: globalThis.Array.isArray(object?.delimiter)
        ? object.delimiter.map((e: any) => globalThis.String(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => TableNode_Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: TableNode): unknown {
    const obj: any = {};
    if (message.header?.length) {
      obj.header = message.header;
    }
    if (message.delimiter?.length) {
      obj.delimiter = message.delimiter;
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => TableNode_Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TableNode>): TableNode {
    return TableNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableNode>): TableNode {
    const message = createBaseTableNode();
    message.header = object.header?.map((e) => e) || [];
    message.delimiter = object.delimiter?.map((e) => e) || [];
    message.rows = object.rows?.map((e) => TableNode_Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableNode_Row(): TableNode_Row {
  return { cells: [] };
}

export const TableNode_Row: MessageFns<TableNode_Row> = {
  encode(message: TableNode_Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableNode_Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableNode_Row();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableNode_Row {
    return { cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: TableNode_Row): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells;
    }
    return obj;
  },

  create(base?: DeepPartial<TableNode_Row>): TableNode_Row {
    return TableNode_Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableNode_Row>): TableNode_Row {
    const message = createBaseTableNode_Row();
    message.cells = object.cells?.map((e) => e) || [];
    return message;
  },
};

function createBaseEmbeddedContentNode(): EmbeddedContentNode {
  return { resourceName: "", params: "" };
}

export const EmbeddedContentNode: MessageFns<EmbeddedContentNode> = {
  encode(message: EmbeddedContentNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.params !== "") {
      writer.uint32(18).string(message.params);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmbeddedContentNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmbeddedContentNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmbeddedContentNode {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      params: isSet(object.params) ? globalThis.String(object.params) : "",
    };
  },

  toJSON(message: EmbeddedContentNode): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.params !== "") {
      obj.params = message.params;
    }
    return obj;
  },

  create(base?: DeepPartial<EmbeddedContentNode>): EmbeddedContentNode {
    return EmbeddedContentNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmbeddedContentNode>): EmbeddedContentNode {
    const message = createBaseEmbeddedContentNode();
    message.resourceName = object.resourceName ?? "";
    message.params = object.params ?? "";
    return message;
  },
};

function createBaseTextNode(): TextNode {
  return { content: "" };
}

export const TextNode: MessageFns<TextNode> = {
  encode(message: TextNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: TextNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<TextNode>): TextNode {
    return TextNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextNode>): TextNode {
    const message = createBaseTextNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseBoldNode(): BoldNode {
  return { symbol: "", children: [] };
}

export const BoldNode: MessageFns<BoldNode> = {
  encode(message: BoldNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    for (const v of message.children) {
      Node.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoldNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoldNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(Node.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoldNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: BoldNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BoldNode>): BoldNode {
    return BoldNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoldNode>): BoldNode {
    const message = createBaseBoldNode();
    message.symbol = object.symbol ?? "";
    message.children = object.children?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItalicNode(): ItalicNode {
  return { symbol: "", content: "" };
}

export const ItalicNode: MessageFns<ItalicNode> = {
  encode(message: ItalicNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItalicNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItalicNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItalicNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: ItalicNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<ItalicNode>): ItalicNode {
    return ItalicNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ItalicNode>): ItalicNode {
    const message = createBaseItalicNode();
    message.symbol = object.symbol ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseBoldItalicNode(): BoldItalicNode {
  return { symbol: "", content: "" };
}

export const BoldItalicNode: MessageFns<BoldItalicNode> = {
  encode(message: BoldItalicNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoldItalicNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoldItalicNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoldItalicNode {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: BoldItalicNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<BoldItalicNode>): BoldItalicNode {
    return BoldItalicNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoldItalicNode>): BoldItalicNode {
    const message = createBaseBoldItalicNode();
    message.symbol = object.symbol ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseCodeNode(): CodeNode {
  return { content: "" };
}

export const CodeNode: MessageFns<CodeNode> = {
  encode(message: CodeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: CodeNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<CodeNode>): CodeNode {
    return CodeNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CodeNode>): CodeNode {
    const message = createBaseCodeNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseImageNode(): ImageNode {
  return { altText: "", url: "" };
}

export const ImageNode: MessageFns<ImageNode> = {
  encode(message: ImageNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.altText !== "") {
      writer.uint32(10).string(message.altText);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.altText = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageNode {
    return {
      altText: isSet(object.altText) ? globalThis.String(object.altText) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: ImageNode): unknown {
    const obj: any = {};
    if (message.altText !== "") {
      obj.altText = message.altText;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<ImageNode>): ImageNode {
    return ImageNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImageNode>): ImageNode {
    const message = createBaseImageNode();
    message.altText = object.altText ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseLinkNode(): LinkNode {
  return { text: "", url: "" };
}

export const LinkNode: MessageFns<LinkNode> = {
  encode(message: LinkNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkNode {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: LinkNode): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<LinkNode>): LinkNode {
    return LinkNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinkNode>): LinkNode {
    const message = createBaseLinkNode();
    message.text = object.text ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseAutoLinkNode(): AutoLinkNode {
  return { url: "", isRawText: false };
}

export const AutoLinkNode: MessageFns<AutoLinkNode> = {
  encode(message: AutoLinkNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.isRawText !== false) {
      writer.uint32(16).bool(message.isRawText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoLinkNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoLinkNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isRawText = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoLinkNode {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      isRawText: isSet(object.isRawText) ? globalThis.Boolean(object.isRawText) : false,
    };
  },

  toJSON(message: AutoLinkNode): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.isRawText !== false) {
      obj.isRawText = message.isRawText;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoLinkNode>): AutoLinkNode {
    return AutoLinkNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoLinkNode>): AutoLinkNode {
    const message = createBaseAutoLinkNode();
    message.url = object.url ?? "";
    message.isRawText = object.isRawText ?? false;
    return message;
  },
};

function createBaseTagNode(): TagNode {
  return { content: "" };
}

export const TagNode: MessageFns<TagNode> = {
  encode(message: TagNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: TagNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<TagNode>): TagNode {
    return TagNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagNode>): TagNode {
    const message = createBaseTagNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseStrikethroughNode(): StrikethroughNode {
  return { content: "" };
}

export const StrikethroughNode: MessageFns<StrikethroughNode> = {
  encode(message: StrikethroughNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrikethroughNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrikethroughNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrikethroughNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: StrikethroughNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<StrikethroughNode>): StrikethroughNode {
    return StrikethroughNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrikethroughNode>): StrikethroughNode {
    const message = createBaseStrikethroughNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseEscapingCharacterNode(): EscapingCharacterNode {
  return { symbol: "" };
}

export const EscapingCharacterNode: MessageFns<EscapingCharacterNode> = {
  encode(message: EscapingCharacterNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EscapingCharacterNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEscapingCharacterNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EscapingCharacterNode {
    return { symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "" };
  },

  toJSON(message: EscapingCharacterNode): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create(base?: DeepPartial<EscapingCharacterNode>): EscapingCharacterNode {
    return EscapingCharacterNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EscapingCharacterNode>): EscapingCharacterNode {
    const message = createBaseEscapingCharacterNode();
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseMathNode(): MathNode {
  return { content: "" };
}

export const MathNode: MessageFns<MathNode> = {
  encode(message: MathNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MathNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMathNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MathNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: MathNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<MathNode>): MathNode {
    return MathNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MathNode>): MathNode {
    const message = createBaseMathNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseHighlightNode(): HighlightNode {
  return { content: "" };
}

export const HighlightNode: MessageFns<HighlightNode> = {
  encode(message: HighlightNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighlightNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighlightNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HighlightNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: HighlightNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<HighlightNode>): HighlightNode {
    return HighlightNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HighlightNode>): HighlightNode {
    const message = createBaseHighlightNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSubscriptNode(): SubscriptNode {
  return { content: "" };
}

export const SubscriptNode: MessageFns<SubscriptNode> = {
  encode(message: SubscriptNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SubscriptNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptNode>): SubscriptNode {
    return SubscriptNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptNode>): SubscriptNode {
    const message = createBaseSubscriptNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSuperscriptNode(): SuperscriptNode {
  return { content: "" };
}

export const SuperscriptNode: MessageFns<SuperscriptNode> = {
  encode(message: SuperscriptNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuperscriptNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuperscriptNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuperscriptNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SuperscriptNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<SuperscriptNode>): SuperscriptNode {
    return SuperscriptNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuperscriptNode>): SuperscriptNode {
    const message = createBaseSuperscriptNode();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseReferencedContentNode(): ReferencedContentNode {
  return { resourceName: "", params: "" };
}

export const ReferencedContentNode: MessageFns<ReferencedContentNode> = {
  encode(message: ReferencedContentNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    if (message.params !== "") {
      writer.uint32(18).string(message.params);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReferencedContentNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferencedContentNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferencedContentNode {
    return {
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      params: isSet(object.params) ? globalThis.String(object.params) : "",
    };
  },

  toJSON(message: ReferencedContentNode): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.params !== "") {
      obj.params = message.params;
    }
    return obj;
  },

  create(base?: DeepPartial<ReferencedContentNode>): ReferencedContentNode {
    return ReferencedContentNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReferencedContentNode>): ReferencedContentNode {
    const message = createBaseReferencedContentNode();
    message.resourceName = object.resourceName ?? "";
    message.params = object.params ?? "";
    return message;
  },
};

function createBaseSpoilerNode(): SpoilerNode {
  return { content: "" };
}

export const SpoilerNode: MessageFns<SpoilerNode> = {
  encode(message: SpoilerNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpoilerNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpoilerNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpoilerNode {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: SpoilerNode): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<SpoilerNode>): SpoilerNode {
    return SpoilerNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpoilerNode>): SpoilerNode {
    const message = createBaseSpoilerNode();
    message.content = object.content ?? "";
    return message;
  },
};

export type MarkdownServiceDefinition = typeof MarkdownServiceDefinition;
export const MarkdownServiceDefinition = {
  name: "MarkdownService",
  fullName: "memos.api.v1.MarkdownService",
  methods: {
    /** Parses the given markdown content and returns a list of nodes. */
    parseMarkdown: {
      name: "ParseMarkdown",
      requestType: ParseMarkdownRequest,
      requestStream: false,
      responseType: ParseMarkdownResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              27,
              58,
              1,
              42,
              34,
              22,
              47,
              97,
              112,
              105,
              47,
              118,
              49,
              47,
              109,
              97,
              114,
              107,
              100,
              111,
              119,
              110,
              47,
              112,
              97,
              114,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** Restores the given nodes to markdown content. */
    restoreMarkdown: {
      name: "RestoreMarkdown",
      requestType: RestoreMarkdownRequest,
      requestStream: false,
      responseType: RestoreMarkdownResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              29,
              58,
              1,
              42,
              34,
              24,
              47,
              97,
              112,
              105,
              47,
              118,
              49,
              47,
              109,
              97,
              114,
              107,
              100,
              111,
              119,
              110,
              58,
              114,
              101,
              115,
              116,
              111,
              114,
              101,
            ]),
          ],
        },
      },
    },
    /** GetLinkMetadata returns metadata for a given link. */
    getLinkMetadata: {
      name: "GetLinkMetadata",
      requestType: GetLinkMetadataRequest,
      requestStream: false,
      responseType: LinkMetadata,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              32,
              18,
              30,
              47,
              97,
              112,
              105,
              47,
              118,
              49,
              47,
              109,
              97,
              114,
              107,
              100,
              111,
              119,
              110,
              47,
              108,
              105,
              110,
              107,
              58,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
        },
      },
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
